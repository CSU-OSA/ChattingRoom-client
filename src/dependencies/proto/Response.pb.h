// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Response.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Response_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Response_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>

#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

#define PROTOBUF_INTERNAL_EXPORT_Response_2eproto
PROTOBUF_NAMESPACE_OPEN
        namespace internal
        {
            class AnyMetadata;
        }  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Response_2eproto
{
    static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
    static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
    static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Response_2eproto;
namespace proto
{
    namespace response
    {
        class ChannelInfo;

        struct ChannelInfoDefaultTypeInternal;
        extern ChannelInfoDefaultTypeInternal _ChannelInfo_default_instance_;

        class Message;

        struct MessageDefaultTypeInternal;
        extern MessageDefaultTypeInternal _Message_default_instance_;

        class ResponsePOJO;

        struct ResponsePOJODefaultTypeInternal;
        extern ResponsePOJODefaultTypeInternal _ResponsePOJO_default_instance_;

        class Result;

        struct ResultDefaultTypeInternal;
        extern ResultDefaultTypeInternal _Result_default_instance_;
    }  // namespace response
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
        template<>
        ::proto::response::ChannelInfo *Arena::CreateMaybeMessage<::proto::response::ChannelInfo>(Arena *);

        template<>
        ::proto::response::Message *Arena::CreateMaybeMessage<::proto::response::Message>(Arena *);

        template<>
        ::proto::response::ResponsePOJO *Arena::CreateMaybeMessage<::proto::response::ResponsePOJO>(Arena *);

        template<>
        ::proto::response::Result *Arena::CreateMaybeMessage<::proto::response::Result>(Arena *);
PROTOBUF_NAMESPACE_CLOSE
namespace proto
{
    namespace response
    {

        enum ResponsePOJO_Type : int
        {
            ResponsePOJO_Type_RESULT = 0,
            ResponsePOJO_Type_MESSAGE = 1,
            ResponsePOJO_Type_ChannelList = 2,
            ResponsePOJO_Type_ChannelMemberList = 3,
            ResponsePOJO_Type_ResponsePOJO_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
            ResponsePOJO_Type_ResponsePOJO_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
        };

        bool ResponsePOJO_Type_IsValid(int value);

        constexpr ResponsePOJO_Type ResponsePOJO_Type_Type_MIN = ResponsePOJO_Type_RESULT;
        constexpr ResponsePOJO_Type ResponsePOJO_Type_Type_MAX = ResponsePOJO_Type_ChannelMemberList;
        constexpr int ResponsePOJO_Type_Type_ARRAYSIZE = ResponsePOJO_Type_Type_MAX + 1;

        const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *ResponsePOJO_Type_descriptor();

        template<typename T>
        inline const std::string &ResponsePOJO_Type_Name(T enum_t_value)
        {
            static_assert(::std::is_same<T, ResponsePOJO_Type>::value ||
                          ::std::is_integral<T>::value,
                          "Incorrect type passed to function ResponsePOJO_Type_Name.");
            return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
                    ResponsePOJO_Type_descriptor(), enum_t_value);
        }

        inline bool ResponsePOJO_Type_Parse(
                ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponsePOJO_Type *value)
        {
            return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponsePOJO_Type>(
                    ResponsePOJO_Type_descriptor(), name, value);
        }
// ===================================================================

        class ResponsePOJO final :
                public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.response.ResponsePOJO) */ {
        public:
            inline ResponsePOJO() : ResponsePOJO(nullptr)
            {}

            ~ResponsePOJO() override;

            explicit constexpr ResponsePOJO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

            ResponsePOJO(const ResponsePOJO &from);

            ResponsePOJO(ResponsePOJO &&from) noexcept
                    : ResponsePOJO()
            {
                *this = ::std::move(from);
            }

            inline ResponsePOJO &operator=(const ResponsePOJO &from)
            {
                CopyFrom(from);
                return *this;
            }

            inline ResponsePOJO &operator=(ResponsePOJO &&from) noexcept
            {
                if (this == &from) return *this;
                if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                    && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
                        )
                {
                    InternalSwap(&from);
                } else
                {
                    CopyFrom(from);
                }
                return *this;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
            {
                return GetDescriptor();
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
            {
                return default_instance().GetMetadata().descriptor;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
            {
                return default_instance().GetMetadata().reflection;
            }

            static const ResponsePOJO &default_instance()
            {
                return *internal_default_instance();
            }

            static inline const ResponsePOJO *internal_default_instance()
            {
                return reinterpret_cast<const ResponsePOJO *>(
                        &_ResponsePOJO_default_instance_);
            }

            static constexpr int kIndexInFileMessages =
                    0;

            friend void swap(ResponsePOJO &a, ResponsePOJO &b)
            {
                a.Swap(&b);
            }

            inline void Swap(ResponsePOJO *other)
            {
                if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
                if (GetOwningArena() != nullptr &&
                    GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
                if (GetOwningArena() == other->GetOwningArena())
                {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
                    InternalSwap(other);
                } else
                {
                    ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
                }
            }

            void UnsafeArenaSwap(ResponsePOJO *other)
            {
                if (other == this) return;
                GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
                InternalSwap(other);
            }

            // implements Message ----------------------------------------------

            ResponsePOJO *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
            {
                return CreateMaybeMessage<ResponsePOJO>(arena);
            }

            using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;

            void CopyFrom(const ResponsePOJO &from);

            using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

            void MergeFrom(const ResponsePOJO &from);

        private:
            static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message *to, const ::PROTOBUF_NAMESPACE_ID::Message &from);

        public:
            PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;

            bool IsInitialized() const final;

            size_t ByteSizeLong() const final;

            const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;

            uint8_t *_InternalSerialize(
                    uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

            int GetCachedSize() const final
            { return _cached_size_.Get(); }

        private:
            void SharedCtor();

            void SharedDtor();

            void SetCachedSize(int size) const final;

            void InternalSwap(ResponsePOJO *other);

        private:
            friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

            static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
            {
                return "proto.response.ResponsePOJO";
            }

        protected:
            explicit ResponsePOJO(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                                  bool is_message_owned = false);

        private:
            static void ArenaDtor(void *object);

            inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

        public:

            static const ClassData _class_data_;

            const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

            ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

            // nested types ----------------------------------------------------

            typedef ResponsePOJO_Type Type;
            static constexpr Type RESULT =
                    ResponsePOJO_Type_RESULT;
            static constexpr Type MESSAGE =
                    ResponsePOJO_Type_MESSAGE;
            static constexpr Type ChannelList =
                    ResponsePOJO_Type_ChannelList;
            static constexpr Type ChannelMemberList =
                    ResponsePOJO_Type_ChannelMemberList;

            static inline bool Type_IsValid(int value)
            {
                return ResponsePOJO_Type_IsValid(value);
            }

            static constexpr Type Type_MIN =
                    ResponsePOJO_Type_Type_MIN;
            static constexpr Type Type_MAX =
                    ResponsePOJO_Type_Type_MAX;
            static constexpr int Type_ARRAYSIZE =
                    ResponsePOJO_Type_Type_ARRAYSIZE;

            static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *
            Type_descriptor()
            {
                return ResponsePOJO_Type_descriptor();
            }

            template<typename T>
            static inline const std::string &Type_Name(T enum_t_value)
            {
                static_assert(::std::is_same<T, Type>::value ||
                              ::std::is_integral<T>::value,
                              "Incorrect type passed to function Type_Name.");
                return ResponsePOJO_Type_Name(enum_t_value);
            }

            static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
                                          Type *value)
            {
                return ResponsePOJO_Type_Parse(name, value);
            }

            // accessors -------------------------------------------------------

            enum : int
            {
                kMessageFieldNumber = 2,
                kChannelInfoFieldNumber = 4,
                kMemberNickFieldNumber = 5,
                kResultFieldNumber = 3,
                kTypeFieldNumber = 1,
            };

            // repeated .proto.response.Message message = 2;
            int message_size() const;

        private:
            int _internal_message_size() const;

        public:
            void clear_message();

            ::proto::response::Message *mutable_message(int index);

            ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::response::Message> *
            mutable_message();

        private:
            const ::proto::response::Message &_internal_message(int index) const;

            ::proto::response::Message *_internal_add_message();

        public:
            const ::proto::response::Message &message(int index) const;

            ::proto::response::Message *add_message();

            const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::response::Message> &
            message() const;

            // repeated .proto.response.ChannelInfo channelInfo = 4;
            int channelinfo_size() const;

        private:
            int _internal_channelinfo_size() const;

        public:
            void clear_channelinfo();

            ::proto::response::ChannelInfo *mutable_channelinfo(int index);

            ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::response::ChannelInfo> *
            mutable_channelinfo();

        private:
            const ::proto::response::ChannelInfo &_internal_channelinfo(int index) const;

            ::proto::response::ChannelInfo *_internal_add_channelinfo();

        public:
            const ::proto::response::ChannelInfo &channelinfo(int index) const;

            ::proto::response::ChannelInfo *add_channelinfo();

            const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::response::ChannelInfo> &
            channelinfo() const;

            // repeated string memberNick = 5;
            int membernick_size() const;

        private:
            int _internal_membernick_size() const;

        public:
            void clear_membernick();

            const std::string &membernick(int index) const;

            std::string *mutable_membernick(int index);

            void set_membernick(int index, const std::string &value);

            void set_membernick(int index, std::string &&value);

            void set_membernick(int index, const char *value);

            void set_membernick(int index, const char *value, size_t size);

            std::string *add_membernick();

            void add_membernick(const std::string &value);

            void add_membernick(std::string &&value);

            void add_membernick(const char *value);

            void add_membernick(const char *value, size_t size);

            const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> &membernick() const;

            ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> *mutable_membernick();

        private:
            const std::string &_internal_membernick(int index) const;

            std::string *_internal_add_membernick();

        public:

            // optional .proto.response.Result result = 3;
            bool has_result() const;

        private:
            bool _internal_has_result() const;

        public:
            void clear_result();

            const ::proto::response::Result &result() const;

            PROTOBUF_NODISCARD ::proto::response::Result *release_result();

            ::proto::response::Result *mutable_result();

            void set_allocated_result(::proto::response::Result *result);

        private:
            const ::proto::response::Result &_internal_result() const;

            ::proto::response::Result *_internal_mutable_result();

        public:
            void unsafe_arena_set_allocated_result(
                    ::proto::response::Result *result);

            ::proto::response::Result *unsafe_arena_release_result();

            // .proto.response.ResponsePOJO.Type type = 1;
            void clear_type();

            ::proto::response::ResponsePOJO_Type type() const;

            void set_type(::proto::response::ResponsePOJO_Type value);

        private:
            ::proto::response::ResponsePOJO_Type _internal_type() const;

            void _internal_set_type(::proto::response::ResponsePOJO_Type value);

        public:

            // @@protoc_insertion_point(class_scope:proto.response.ResponsePOJO)
        private:
            class _Internal;

            template<typename T> friend
            class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;

            typedef void InternalArenaConstructable_;
            typedef void DestructorSkippable_;
            ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
            ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::response::Message> message_;
            ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::response::ChannelInfo> channelinfo_;
            ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> membernick_;
            ::proto::response::Result *result_;
            int type_;
            friend struct ::TableStruct_Response_2eproto;
        };
// -------------------------------------------------------------------

        class Result final :
                public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.response.Result) */ {
        public:
            inline Result() : Result(nullptr)
            {}

            ~Result() override;

            explicit constexpr Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

            Result(const Result &from);

            Result(Result &&from) noexcept
                    : Result()
            {
                *this = ::std::move(from);
            }

            inline Result &operator=(const Result &from)
            {
                CopyFrom(from);
                return *this;
            }

            inline Result &operator=(Result &&from) noexcept
            {
                if (this == &from) return *this;
                if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                    && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
                        )
                {
                    InternalSwap(&from);
                } else
                {
                    CopyFrom(from);
                }
                return *this;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
            {
                return GetDescriptor();
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
            {
                return default_instance().GetMetadata().descriptor;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
            {
                return default_instance().GetMetadata().reflection;
            }

            static const Result &default_instance()
            {
                return *internal_default_instance();
            }

            static inline const Result *internal_default_instance()
            {
                return reinterpret_cast<const Result *>(
                        &_Result_default_instance_);
            }

            static constexpr int kIndexInFileMessages =
                    1;

            friend void swap(Result &a, Result &b)
            {
                a.Swap(&b);
            }

            inline void Swap(Result *other)
            {
                if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
                if (GetOwningArena() != nullptr &&
                    GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
                if (GetOwningArena() == other->GetOwningArena())
                {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
                    InternalSwap(other);
                } else
                {
                    ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
                }
            }

            void UnsafeArenaSwap(Result *other)
            {
                if (other == this) return;
                GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
                InternalSwap(other);
            }

            // implements Message ----------------------------------------------

            Result *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
            {
                return CreateMaybeMessage<Result>(arena);
            }

            using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;

            void CopyFrom(const Result &from);

            using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

            void MergeFrom(const Result &from);

        private:
            static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message *to, const ::PROTOBUF_NAMESPACE_ID::Message &from);

        public:
            PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;

            bool IsInitialized() const final;

            size_t ByteSizeLong() const final;

            const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;

            uint8_t *_InternalSerialize(
                    uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

            int GetCachedSize() const final
            { return _cached_size_.Get(); }

        private:
            void SharedCtor();

            void SharedDtor();

            void SetCachedSize(int size) const final;

            void InternalSwap(Result *other);

        private:
            friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

            static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
            {
                return "proto.response.Result";
            }

        protected:
            explicit Result(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                            bool is_message_owned = false);

        private:
            static void ArenaDtor(void *object);

            inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

        public:

            static const ClassData _class_data_;

            const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

            ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            enum : int
            {
                kMsgFieldNumber = 2,
                kResultFieldNumber = 1,
            };

            // string msg = 2;
            void clear_msg();

            const std::string &msg() const;

            template<typename ArgT0 = const std::string &, typename... ArgT>
            void set_msg(ArgT0 &&arg0, ArgT... args);

            std::string *mutable_msg();

            PROTOBUF_NODISCARD std::string *release_msg();

            void set_allocated_msg(std::string *msg);

        private:
            const std::string &_internal_msg() const;

            inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string &value);

            std::string *_internal_mutable_msg();

        public:

            // bool result = 1;
            void clear_result();

            bool result() const;

            void set_result(bool value);

        private:
            bool _internal_result() const;

            void _internal_set_result(bool value);

        public:

            // @@protoc_insertion_point(class_scope:proto.response.Result)
        private:
            class _Internal;

            template<typename T> friend
            class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;

            typedef void InternalArenaConstructable_;
            typedef void DestructorSkippable_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
            bool result_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
            friend struct ::TableStruct_Response_2eproto;
        };
// -------------------------------------------------------------------

        class Message final :
                public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.response.Message) */ {
        public:
            inline Message() : Message(nullptr)
            {}

            ~Message() override;

            explicit constexpr Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

            Message(const Message &from);

            Message(Message &&from) noexcept
                    : Message()
            {
                *this = ::std::move(from);
            }

            inline Message &operator=(const Message &from)
            {
                CopyFrom(from);
                return *this;
            }

            inline Message &operator=(Message &&from) noexcept
            {
                if (this == &from) return *this;
                if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                    && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
                        )
                {
                    InternalSwap(&from);
                } else
                {
                    CopyFrom(from);
                }
                return *this;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
            {
                return GetDescriptor();
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
            {
                return default_instance().GetMetadata().descriptor;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
            {
                return default_instance().GetMetadata().reflection;
            }

            static const Message &default_instance()
            {
                return *internal_default_instance();
            }

            static inline const Message *internal_default_instance()
            {
                return reinterpret_cast<const Message *>(
                        &_Message_default_instance_);
            }

            static constexpr int kIndexInFileMessages =
                    2;

            friend void swap(Message &a, Message &b)
            {
                a.Swap(&b);
            }

            inline void Swap(Message *other)
            {
                if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
                if (GetOwningArena() != nullptr &&
                    GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
                if (GetOwningArena() == other->GetOwningArena())
                {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
                    InternalSwap(other);
                } else
                {
                    ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
                }
            }

            void UnsafeArenaSwap(Message *other)
            {
                if (other == this) return;
                GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
                InternalSwap(other);
            }

            // implements Message ----------------------------------------------

            Message *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
            {
                return CreateMaybeMessage<Message>(arena);
            }

            using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;

            void CopyFrom(const Message &from);

            using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

            void MergeFrom(const Message &from);

        private:
            static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message *to, const ::PROTOBUF_NAMESPACE_ID::Message &from);

        public:
            PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;

            bool IsInitialized() const final;

            size_t ByteSizeLong() const final;

            const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;

            uint8_t *_InternalSerialize(
                    uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

            int GetCachedSize() const final
            { return _cached_size_.Get(); }

        private:
            void SharedCtor();

            void SharedDtor();

            void SetCachedSize(int size) const final;

            void InternalSwap(Message *other);

        private:
            friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

            static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
            {
                return "proto.response.Message";
            }

        protected:
            explicit Message(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                             bool is_message_owned = false);

        private:
            static void ArenaDtor(void *object);

            inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

        public:

            static const ClassData _class_data_;

            const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

            ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            enum : int
            {
                kRecTimeFieldNumber = 1,
                kChannelFieldNumber = 2,
                kFromNickFieldNumber = 3,
                kContentFieldNumber = 4,
            };

            // string recTime = 1;
            void clear_rectime();

            const std::string &rectime() const;

            template<typename ArgT0 = const std::string &, typename... ArgT>
            void set_rectime(ArgT0 &&arg0, ArgT... args);

            std::string *mutable_rectime();

            PROTOBUF_NODISCARD std::string *release_rectime();

            void set_allocated_rectime(std::string *rectime);

        private:
            const std::string &_internal_rectime() const;

            inline PROTOBUF_ALWAYS_INLINE void _internal_set_rectime(const std::string &value);

            std::string *_internal_mutable_rectime();

        public:

            // string channel = 2;
            void clear_channel();

            const std::string &channel() const;

            template<typename ArgT0 = const std::string &, typename... ArgT>
            void set_channel(ArgT0 &&arg0, ArgT... args);

            std::string *mutable_channel();

            PROTOBUF_NODISCARD std::string *release_channel();

            void set_allocated_channel(std::string *channel);

        private:
            const std::string &_internal_channel() const;

            inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel(const std::string &value);

            std::string *_internal_mutable_channel();

        public:

            // string fromNick = 3;
            void clear_fromnick();

            const std::string &fromnick() const;

            template<typename ArgT0 = const std::string &, typename... ArgT>
            void set_fromnick(ArgT0 &&arg0, ArgT... args);

            std::string *mutable_fromnick();

            PROTOBUF_NODISCARD std::string *release_fromnick();

            void set_allocated_fromnick(std::string *fromnick);

        private:
            const std::string &_internal_fromnick() const;

            inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromnick(const std::string &value);

            std::string *_internal_mutable_fromnick();

        public:

            // string content = 4;
            void clear_content();

            const std::string &content() const;

            template<typename ArgT0 = const std::string &, typename... ArgT>
            void set_content(ArgT0 &&arg0, ArgT... args);

            std::string *mutable_content();

            PROTOBUF_NODISCARD std::string *release_content();

            void set_allocated_content(std::string *content);

        private:
            const std::string &_internal_content() const;

            inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string &value);

            std::string *_internal_mutable_content();

        public:

            // @@protoc_insertion_point(class_scope:proto.response.Message)
        private:
            class _Internal;

            template<typename T> friend
            class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;

            typedef void InternalArenaConstructable_;
            typedef void DestructorSkippable_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rectime_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fromnick_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
            friend struct ::TableStruct_Response_2eproto;
        };
// -------------------------------------------------------------------

        class ChannelInfo final :
                public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.response.ChannelInfo) */ {
        public:
            inline ChannelInfo() : ChannelInfo(nullptr)
            {}

            ~ChannelInfo() override;

            explicit constexpr ChannelInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

            ChannelInfo(const ChannelInfo &from);

            ChannelInfo(ChannelInfo &&from) noexcept
                    : ChannelInfo()
            {
                *this = ::std::move(from);
            }

            inline ChannelInfo &operator=(const ChannelInfo &from)
            {
                CopyFrom(from);
                return *this;
            }

            inline ChannelInfo &operator=(ChannelInfo &&from) noexcept
            {
                if (this == &from) return *this;
                if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
                    && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
                        )
                {
                    InternalSwap(&from);
                } else
                {
                    CopyFrom(from);
                }
                return *this;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
            {
                return GetDescriptor();
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
            {
                return default_instance().GetMetadata().descriptor;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
            {
                return default_instance().GetMetadata().reflection;
            }

            static const ChannelInfo &default_instance()
            {
                return *internal_default_instance();
            }

            static inline const ChannelInfo *internal_default_instance()
            {
                return reinterpret_cast<const ChannelInfo *>(
                        &_ChannelInfo_default_instance_);
            }

            static constexpr int kIndexInFileMessages =
                    3;

            friend void swap(ChannelInfo &a, ChannelInfo &b)
            {
                a.Swap(&b);
            }

            inline void Swap(ChannelInfo *other)
            {
                if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
                if (GetOwningArena() != nullptr &&
                    GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
                if (GetOwningArena() == other->GetOwningArena())
                {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
                    InternalSwap(other);
                } else
                {
                    ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
                }
            }

            void UnsafeArenaSwap(ChannelInfo *other)
            {
                if (other == this) return;
                GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
                InternalSwap(other);
            }

            // implements Message ----------------------------------------------

            ChannelInfo *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
            {
                return CreateMaybeMessage<ChannelInfo>(arena);
            }

            using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;

            void CopyFrom(const ChannelInfo &from);

            using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

            void MergeFrom(const ChannelInfo &from);

        private:
            static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message *to, const ::PROTOBUF_NAMESPACE_ID::Message &from);

        public:
            PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;

            bool IsInitialized() const final;

            size_t ByteSizeLong() const final;

            const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;

            uint8_t *_InternalSerialize(
                    uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

            int GetCachedSize() const final
            { return _cached_size_.Get(); }

        private:
            void SharedCtor();

            void SharedDtor();

            void SetCachedSize(int size) const final;

            void InternalSwap(ChannelInfo *other);

        private:
            friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

            static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
            {
                return "proto.response.ChannelInfo";
            }

        protected:
            explicit ChannelInfo(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                                 bool is_message_owned = false);

        private:
            static void ArenaDtor(void *object);

            inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

        public:

            static const ClassData _class_data_;

            const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

            ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            enum : int
            {
                kNameFieldNumber = 1,
                kIsPublicFieldNumber = 2,
                kMemberNumFieldNumber = 3,
            };

            // string name = 1;
            void clear_name();

            const std::string &name() const;

            template<typename ArgT0 = const std::string &, typename... ArgT>
            void set_name(ArgT0 &&arg0, ArgT... args);

            std::string *mutable_name();

            PROTOBUF_NODISCARD std::string *release_name();

            void set_allocated_name(std::string *name);

        private:
            const std::string &_internal_name() const;

            inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string &value);

            std::string *_internal_mutable_name();

        public:

            // bool isPublic = 2;
            void clear_ispublic();

            bool ispublic() const;

            void set_ispublic(bool value);

        private:
            bool _internal_ispublic() const;

            void _internal_set_ispublic(bool value);

        public:

            // int32 memberNum = 3;
            void clear_membernum();

            int32_t membernum() const;

            void set_membernum(int32_t value);

        private:
            int32_t _internal_membernum() const;

            void _internal_set_membernum(int32_t value);

        public:

            // @@protoc_insertion_point(class_scope:proto.response.ChannelInfo)
        private:
            class _Internal;

            template<typename T> friend
            class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;

            typedef void InternalArenaConstructable_;
            typedef void DestructorSkippable_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
            bool ispublic_;
            int32_t membernum_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
            friend struct ::TableStruct_Response_2eproto;
        };
// ===================================================================


// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ResponsePOJO

// .proto.response.ResponsePOJO.Type type = 1;
        inline void ResponsePOJO::clear_type()
        {
            type_ = 0;
        }

        inline ::proto::response::ResponsePOJO_Type ResponsePOJO::_internal_type() const
        {
            return static_cast< ::proto::response::ResponsePOJO_Type >(type_);
        }

        inline ::proto::response::ResponsePOJO_Type ResponsePOJO::type() const
        {
            // @@protoc_insertion_point(field_get:proto.response.ResponsePOJO.type)
            return _internal_type();
        }

        inline void ResponsePOJO::_internal_set_type(::proto::response::ResponsePOJO_Type value)
        {

            type_ = value;
        }

        inline void ResponsePOJO::set_type(::proto::response::ResponsePOJO_Type value)
        {
            _internal_set_type(value);
            // @@protoc_insertion_point(field_set:proto.response.ResponsePOJO.type)
        }

// repeated .proto.response.Message message = 2;
        inline int ResponsePOJO::_internal_message_size() const
        {
            return message_.size();
        }

        inline int ResponsePOJO::message_size() const
        {
            return _internal_message_size();
        }

        inline void ResponsePOJO::clear_message()
        {
            message_.Clear();
        }

        inline ::proto::response::Message *ResponsePOJO::mutable_message(int index)
        {
            // @@protoc_insertion_point(field_mutable:proto.response.ResponsePOJO.message)
            return message_.Mutable(index);
        }

        inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::response::Message> *
        ResponsePOJO::mutable_message()
        {
            // @@protoc_insertion_point(field_mutable_list:proto.response.ResponsePOJO.message)
            return &message_;
        }

        inline const ::proto::response::Message &ResponsePOJO::_internal_message(int index) const
        {
            return message_.Get(index);
        }

        inline const ::proto::response::Message &ResponsePOJO::message(int index) const
        {
            // @@protoc_insertion_point(field_get:proto.response.ResponsePOJO.message)
            return _internal_message(index);
        }

        inline ::proto::response::Message *ResponsePOJO::_internal_add_message()
        {
            return message_.Add();
        }

        inline ::proto::response::Message *ResponsePOJO::add_message()
        {
            ::proto::response::Message *_add = _internal_add_message();
            // @@protoc_insertion_point(field_add:proto.response.ResponsePOJO.message)
            return _add;
        }

        inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::response::Message> &
        ResponsePOJO::message() const
        {
            // @@protoc_insertion_point(field_list:proto.response.ResponsePOJO.message)
            return message_;
        }

// optional .proto.response.Result result = 3;
        inline bool ResponsePOJO::_internal_has_result() const
        {
            bool value = (_has_bits_[0] & 0x00000001u) != 0;
            PROTOBUF_ASSUME(!value || result_ != nullptr);
            return value;
        }

        inline bool ResponsePOJO::has_result() const
        {
            return _internal_has_result();
        }

        inline void ResponsePOJO::clear_result()
        {
            if (result_ != nullptr) result_->Clear();
            _has_bits_[0] &= ~0x00000001u;
        }

        inline const ::proto::response::Result &ResponsePOJO::_internal_result() const
        {
            const ::proto::response::Result *p = result_;
            return p != nullptr ? *p : reinterpret_cast<const ::proto::response::Result &>(
                    ::proto::response::_Result_default_instance_);
        }

        inline const ::proto::response::Result &ResponsePOJO::result() const
        {
            // @@protoc_insertion_point(field_get:proto.response.ResponsePOJO.result)
            return _internal_result();
        }

        inline void ResponsePOJO::unsafe_arena_set_allocated_result(
                ::proto::response::Result *result)
        {
            if (GetArenaForAllocation() == nullptr)
            {
                delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(result_);
            }
            result_ = result;
            if (result)
            {
                _has_bits_[0] |= 0x00000001u;
            } else
            {
                _has_bits_[0] &= ~0x00000001u;
            }
            // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.response.ResponsePOJO.result)
        }

        inline ::proto::response::Result *ResponsePOJO::release_result()
        {
            _has_bits_[0] &= ~0x00000001u;
            ::proto::response::Result *temp = result_;
            result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
            auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
            if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
            if (GetArenaForAllocation() != nullptr)
            {
                temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
            }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
            return temp;
        }

        inline ::proto::response::Result *ResponsePOJO::unsafe_arena_release_result()
        {
            // @@protoc_insertion_point(field_release:proto.response.ResponsePOJO.result)
            _has_bits_[0] &= ~0x00000001u;
            ::proto::response::Result *temp = result_;
            result_ = nullptr;
            return temp;
        }

        inline ::proto::response::Result *ResponsePOJO::_internal_mutable_result()
        {
            _has_bits_[0] |= 0x00000001u;
            if (result_ == nullptr)
            {
                auto *p = CreateMaybeMessage<::proto::response::Result>(GetArenaForAllocation());
                result_ = p;
            }
            return result_;
        }

        inline ::proto::response::Result *ResponsePOJO::mutable_result()
        {
            ::proto::response::Result *_msg = _internal_mutable_result();
            // @@protoc_insertion_point(field_mutable:proto.response.ResponsePOJO.result)
            return _msg;
        }

        inline void ResponsePOJO::set_allocated_result(::proto::response::Result *result)
        {
            ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaForAllocation();
            if (message_arena == nullptr)
            {
                delete result_;
            }
            if (result)
            {
                ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
                        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::proto::response::Result>::GetOwningArena(
                                result);
                if (message_arena != submessage_arena)
                {
                    result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                            message_arena, result, submessage_arena);
                }
                _has_bits_[0] |= 0x00000001u;
            } else
            {
                _has_bits_[0] &= ~0x00000001u;
            }
            result_ = result;
            // @@protoc_insertion_point(field_set_allocated:proto.response.ResponsePOJO.result)
        }

// repeated .proto.response.ChannelInfo channelInfo = 4;
        inline int ResponsePOJO::_internal_channelinfo_size() const
        {
            return channelinfo_.size();
        }

        inline int ResponsePOJO::channelinfo_size() const
        {
            return _internal_channelinfo_size();
        }

        inline void ResponsePOJO::clear_channelinfo()
        {
            channelinfo_.Clear();
        }

        inline ::proto::response::ChannelInfo *ResponsePOJO::mutable_channelinfo(int index)
        {
            // @@protoc_insertion_point(field_mutable:proto.response.ResponsePOJO.channelInfo)
            return channelinfo_.Mutable(index);
        }

        inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::response::ChannelInfo> *
        ResponsePOJO::mutable_channelinfo()
        {
            // @@protoc_insertion_point(field_mutable_list:proto.response.ResponsePOJO.channelInfo)
            return &channelinfo_;
        }

        inline const ::proto::response::ChannelInfo &ResponsePOJO::_internal_channelinfo(int index) const
        {
            return channelinfo_.Get(index);
        }

        inline const ::proto::response::ChannelInfo &ResponsePOJO::channelinfo(int index) const
        {
            // @@protoc_insertion_point(field_get:proto.response.ResponsePOJO.channelInfo)
            return _internal_channelinfo(index);
        }

        inline ::proto::response::ChannelInfo *ResponsePOJO::_internal_add_channelinfo()
        {
            return channelinfo_.Add();
        }

        inline ::proto::response::ChannelInfo *ResponsePOJO::add_channelinfo()
        {
            ::proto::response::ChannelInfo *_add = _internal_add_channelinfo();
            // @@protoc_insertion_point(field_add:proto.response.ResponsePOJO.channelInfo)
            return _add;
        }

        inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::proto::response::ChannelInfo> &
        ResponsePOJO::channelinfo() const
        {
            // @@protoc_insertion_point(field_list:proto.response.ResponsePOJO.channelInfo)
            return channelinfo_;
        }

// repeated string memberNick = 5;
        inline int ResponsePOJO::_internal_membernick_size() const
        {
            return membernick_.size();
        }

        inline int ResponsePOJO::membernick_size() const
        {
            return _internal_membernick_size();
        }

        inline void ResponsePOJO::clear_membernick()
        {
            membernick_.Clear();
        }

        inline std::string *ResponsePOJO::add_membernick()
        {
            std::string *_s = _internal_add_membernick();
            // @@protoc_insertion_point(field_add_mutable:proto.response.ResponsePOJO.memberNick)
            return _s;
        }

        inline const std::string &ResponsePOJO::_internal_membernick(int index) const
        {
            return membernick_.Get(index);
        }

        inline const std::string &ResponsePOJO::membernick(int index) const
        {
            // @@protoc_insertion_point(field_get:proto.response.ResponsePOJO.memberNick)
            return _internal_membernick(index);
        }

        inline std::string *ResponsePOJO::mutable_membernick(int index)
        {
            // @@protoc_insertion_point(field_mutable:proto.response.ResponsePOJO.memberNick)
            return membernick_.Mutable(index);
        }

        inline void ResponsePOJO::set_membernick(int index, const std::string &value)
        {
            membernick_.Mutable(index)->assign(value);
            // @@protoc_insertion_point(field_set:proto.response.ResponsePOJO.memberNick)
        }

        inline void ResponsePOJO::set_membernick(int index, std::string &&value)
        {
            membernick_.Mutable(index)->assign(std::move(value));
            // @@protoc_insertion_point(field_set:proto.response.ResponsePOJO.memberNick)
        }

        inline void ResponsePOJO::set_membernick(int index, const char *value)
        {
            GOOGLE_DCHECK(value != nullptr);
            membernick_.Mutable(index)->assign(value);
            // @@protoc_insertion_point(field_set_char:proto.response.ResponsePOJO.memberNick)
        }

        inline void ResponsePOJO::set_membernick(int index, const char *value, size_t size)
        {
            membernick_.Mutable(index)->assign(
                    reinterpret_cast<const char *>(value), size);
            // @@protoc_insertion_point(field_set_pointer:proto.response.ResponsePOJO.memberNick)
        }

        inline std::string *ResponsePOJO::_internal_add_membernick()
        {
            return membernick_.Add();
        }

        inline void ResponsePOJO::add_membernick(const std::string &value)
        {
            membernick_.Add()->assign(value);
            // @@protoc_insertion_point(field_add:proto.response.ResponsePOJO.memberNick)
        }

        inline void ResponsePOJO::add_membernick(std::string &&value)
        {
            membernick_.Add(std::move(value));
            // @@protoc_insertion_point(field_add:proto.response.ResponsePOJO.memberNick)
        }

        inline void ResponsePOJO::add_membernick(const char *value)
        {
            GOOGLE_DCHECK(value != nullptr);
            membernick_.Add()->assign(value);
            // @@protoc_insertion_point(field_add_char:proto.response.ResponsePOJO.memberNick)
        }

        inline void ResponsePOJO::add_membernick(const char *value, size_t size)
        {
            membernick_.Add()->assign(reinterpret_cast<const char *>(value), size);
            // @@protoc_insertion_point(field_add_pointer:proto.response.ResponsePOJO.memberNick)
        }

        inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> &
        ResponsePOJO::membernick() const
        {
            // @@protoc_insertion_point(field_list:proto.response.ResponsePOJO.memberNick)
            return membernick_;
        }

        inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> *
        ResponsePOJO::mutable_membernick()
        {
            // @@protoc_insertion_point(field_mutable_list:proto.response.ResponsePOJO.memberNick)
            return &membernick_;
        }

// -------------------------------------------------------------------

// Result

// bool result = 1;
        inline void Result::clear_result()
        {
            result_ = false;
        }

        inline bool Result::_internal_result() const
        {
            return result_;
        }

        inline bool Result::result() const
        {
            // @@protoc_insertion_point(field_get:proto.response.Result.result)
            return _internal_result();
        }

        inline void Result::_internal_set_result(bool value)
        {

            result_ = value;
        }

        inline void Result::set_result(bool value)
        {
            _internal_set_result(value);
            // @@protoc_insertion_point(field_set:proto.response.Result.result)
        }

// string msg = 2;
        inline void Result::clear_msg()
        {
            msg_.ClearToEmpty();
        }

        inline const std::string &Result::msg() const
        {
            // @@protoc_insertion_point(field_get:proto.response.Result.msg)
            return _internal_msg();
        }

        template<typename ArgT0, typename... ArgT>
        inline PROTOBUF_ALWAYS_INLINE
        void Result::set_msg(ArgT0 &&arg0, ArgT... args)
        {

            msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0),
                     args..., GetArenaForAllocation());
            // @@protoc_insertion_point(field_set:proto.response.Result.msg)
        }

        inline std::string *Result::mutable_msg()
        {
            std::string *_s = _internal_mutable_msg();
            // @@protoc_insertion_point(field_mutable:proto.response.Result.msg)
            return _s;
        }

        inline const std::string &Result::_internal_msg() const
        {
            return msg_.Get();
        }

        inline void Result::_internal_set_msg(const std::string &value)
        {

            msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
        }

        inline std::string *Result::_internal_mutable_msg()
        {

            return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                GetArenaForAllocation());
        }

        inline std::string *Result::release_msg()
        {
            // @@protoc_insertion_point(field_release:proto.response.Result.msg)
            return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                GetArenaForAllocation());
        }

        inline void Result::set_allocated_msg(std::string *msg)
        {
            if (msg != nullptr)
            {

            } else
            {

            }
            msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
                              GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
            if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
              msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
            }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
            // @@protoc_insertion_point(field_set_allocated:proto.response.Result.msg)
        }

// -------------------------------------------------------------------

// Message

// string recTime = 1;
        inline void Message::clear_rectime()
        {
            rectime_.ClearToEmpty();
        }

        inline const std::string &Message::rectime() const
        {
            // @@protoc_insertion_point(field_get:proto.response.Message.recTime)
            return _internal_rectime();
        }

        template<typename ArgT0, typename... ArgT>
        inline PROTOBUF_ALWAYS_INLINE
        void Message::set_rectime(ArgT0 &&arg0, ArgT... args)
        {

            rectime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0),
                         args..., GetArenaForAllocation());
            // @@protoc_insertion_point(field_set:proto.response.Message.recTime)
        }

        inline std::string *Message::mutable_rectime()
        {
            std::string *_s = _internal_mutable_rectime();
            // @@protoc_insertion_point(field_mutable:proto.response.Message.recTime)
            return _s;
        }

        inline const std::string &Message::_internal_rectime() const
        {
            return rectime_.Get();
        }

        inline void Message::_internal_set_rectime(const std::string &value)
        {

            rectime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                         GetArenaForAllocation());
        }

        inline std::string *Message::_internal_mutable_rectime()
        {

            return rectime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                    GetArenaForAllocation());
        }

        inline std::string *Message::release_rectime()
        {
            // @@protoc_insertion_point(field_release:proto.response.Message.recTime)
            return rectime_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                    GetArenaForAllocation());
        }

        inline void Message::set_allocated_rectime(std::string *rectime)
        {
            if (rectime != nullptr)
            {

            } else
            {

            }
            rectime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rectime,
                                  GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
            if (rectime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
              rectime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
            }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
            // @@protoc_insertion_point(field_set_allocated:proto.response.Message.recTime)
        }

// string channel = 2;
        inline void Message::clear_channel()
        {
            channel_.ClearToEmpty();
        }

        inline const std::string &Message::channel() const
        {
            // @@protoc_insertion_point(field_get:proto.response.Message.channel)
            return _internal_channel();
        }

        template<typename ArgT0, typename... ArgT>
        inline PROTOBUF_ALWAYS_INLINE
        void Message::set_channel(ArgT0 &&arg0, ArgT... args)
        {

            channel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0),
                         args..., GetArenaForAllocation());
            // @@protoc_insertion_point(field_set:proto.response.Message.channel)
        }

        inline std::string *Message::mutable_channel()
        {
            std::string *_s = _internal_mutable_channel();
            // @@protoc_insertion_point(field_mutable:proto.response.Message.channel)
            return _s;
        }

        inline const std::string &Message::_internal_channel() const
        {
            return channel_.Get();
        }

        inline void Message::_internal_set_channel(const std::string &value)
        {

            channel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                         GetArenaForAllocation());
        }

        inline std::string *Message::_internal_mutable_channel()
        {

            return channel_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                    GetArenaForAllocation());
        }

        inline std::string *Message::release_channel()
        {
            // @@protoc_insertion_point(field_release:proto.response.Message.channel)
            return channel_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                    GetArenaForAllocation());
        }

        inline void Message::set_allocated_channel(std::string *channel)
        {
            if (channel != nullptr)
            {

            } else
            {

            }
            channel_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel,
                                  GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
            if (channel_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
              channel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
            }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
            // @@protoc_insertion_point(field_set_allocated:proto.response.Message.channel)
        }

// string fromNick = 3;
        inline void Message::clear_fromnick()
        {
            fromnick_.ClearToEmpty();
        }

        inline const std::string &Message::fromnick() const
        {
            // @@protoc_insertion_point(field_get:proto.response.Message.fromNick)
            return _internal_fromnick();
        }

        template<typename ArgT0, typename... ArgT>
        inline PROTOBUF_ALWAYS_INLINE
        void Message::set_fromnick(ArgT0 &&arg0, ArgT... args)
        {

            fromnick_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                          static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
            // @@protoc_insertion_point(field_set:proto.response.Message.fromNick)
        }

        inline std::string *Message::mutable_fromnick()
        {
            std::string *_s = _internal_mutable_fromnick();
            // @@protoc_insertion_point(field_mutable:proto.response.Message.fromNick)
            return _s;
        }

        inline const std::string &Message::_internal_fromnick() const
        {
            return fromnick_.Get();
        }

        inline void Message::_internal_set_fromnick(const std::string &value)
        {

            fromnick_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                          GetArenaForAllocation());
        }

        inline std::string *Message::_internal_mutable_fromnick()
        {

            return fromnick_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                     GetArenaForAllocation());
        }

        inline std::string *Message::release_fromnick()
        {
            // @@protoc_insertion_point(field_release:proto.response.Message.fromNick)
            return fromnick_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                     GetArenaForAllocation());
        }

        inline void Message::set_allocated_fromnick(std::string *fromnick)
        {
            if (fromnick != nullptr)
            {

            } else
            {

            }
            fromnick_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fromnick,
                                   GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
            if (fromnick_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
              fromnick_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
            }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
            // @@protoc_insertion_point(field_set_allocated:proto.response.Message.fromNick)
        }

// string content = 4;
        inline void Message::clear_content()
        {
            content_.ClearToEmpty();
        }

        inline const std::string &Message::content() const
        {
            // @@protoc_insertion_point(field_get:proto.response.Message.content)
            return _internal_content();
        }

        template<typename ArgT0, typename... ArgT>
        inline PROTOBUF_ALWAYS_INLINE
        void Message::set_content(ArgT0 &&arg0, ArgT... args)
        {

            content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0),
                         args..., GetArenaForAllocation());
            // @@protoc_insertion_point(field_set:proto.response.Message.content)
        }

        inline std::string *Message::mutable_content()
        {
            std::string *_s = _internal_mutable_content();
            // @@protoc_insertion_point(field_mutable:proto.response.Message.content)
            return _s;
        }

        inline const std::string &Message::_internal_content() const
        {
            return content_.Get();
        }

        inline void Message::_internal_set_content(const std::string &value)
        {

            content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                         GetArenaForAllocation());
        }

        inline std::string *Message::_internal_mutable_content()
        {

            return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                    GetArenaForAllocation());
        }

        inline std::string *Message::release_content()
        {
            // @@protoc_insertion_point(field_release:proto.response.Message.content)
            return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                    GetArenaForAllocation());
        }

        inline void Message::set_allocated_content(std::string *content)
        {
            if (content != nullptr)
            {

            } else
            {

            }
            content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
                                  GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
            if (content_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
              content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
            }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
            // @@protoc_insertion_point(field_set_allocated:proto.response.Message.content)
        }

// -------------------------------------------------------------------

// ChannelInfo

// string name = 1;
        inline void ChannelInfo::clear_name()
        {
            name_.ClearToEmpty();
        }

        inline const std::string &ChannelInfo::name() const
        {
            // @@protoc_insertion_point(field_get:proto.response.ChannelInfo.name)
            return _internal_name();
        }

        template<typename ArgT0, typename... ArgT>
        inline PROTOBUF_ALWAYS_INLINE
        void ChannelInfo::set_name(ArgT0 &&arg0, ArgT... args)
        {

            name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0),
                      args..., GetArenaForAllocation());
            // @@protoc_insertion_point(field_set:proto.response.ChannelInfo.name)
        }

        inline std::string *ChannelInfo::mutable_name()
        {
            std::string *_s = _internal_mutable_name();
            // @@protoc_insertion_point(field_mutable:proto.response.ChannelInfo.name)
            return _s;
        }

        inline const std::string &ChannelInfo::_internal_name() const
        {
            return name_.Get();
        }

        inline void ChannelInfo::_internal_set_name(const std::string &value)
        {

            name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                      GetArenaForAllocation());
        }

        inline std::string *ChannelInfo::_internal_mutable_name()
        {

            return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                 GetArenaForAllocation());
        }

        inline std::string *ChannelInfo::release_name()
        {
            // @@protoc_insertion_point(field_release:proto.response.ChannelInfo.name)
            return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                 GetArenaForAllocation());
        }

        inline void ChannelInfo::set_allocated_name(std::string *name)
        {
            if (name != nullptr)
            {

            } else
            {

            }
            name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
                               GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
            if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
              name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
            }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
            // @@protoc_insertion_point(field_set_allocated:proto.response.ChannelInfo.name)
        }

// bool isPublic = 2;
        inline void ChannelInfo::clear_ispublic()
        {
            ispublic_ = false;
        }

        inline bool ChannelInfo::_internal_ispublic() const
        {
            return ispublic_;
        }

        inline bool ChannelInfo::ispublic() const
        {
            // @@protoc_insertion_point(field_get:proto.response.ChannelInfo.isPublic)
            return _internal_ispublic();
        }

        inline void ChannelInfo::_internal_set_ispublic(bool value)
        {

            ispublic_ = value;
        }

        inline void ChannelInfo::set_ispublic(bool value)
        {
            _internal_set_ispublic(value);
            // @@protoc_insertion_point(field_set:proto.response.ChannelInfo.isPublic)
        }

// int32 memberNum = 3;
        inline void ChannelInfo::clear_membernum()
        {
            membernum_ = 0;
        }

        inline int32_t ChannelInfo::_internal_membernum() const
        {
            return membernum_;
        }

        inline int32_t ChannelInfo::membernum() const
        {
            // @@protoc_insertion_point(field_get:proto.response.ChannelInfo.memberNum)
            return _internal_membernum();
        }

        inline void ChannelInfo::_internal_set_membernum(int32_t value)
        {

            membernum_ = value;
        }

        inline void ChannelInfo::set_membernum(int32_t value)
        {
            _internal_set_membernum(value);
            // @@protoc_insertion_point(field_set:proto.response.ChannelInfo.memberNum)
        }

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

    }  // namespace response
}  // namespace proto

PROTOBUF_NAMESPACE_OPEN

        template<>
        struct is_proto_enum<::proto::response::ResponsePOJO_Type> : ::std::true_type
        {
        };

        template<>
        inline const EnumDescriptor *GetEnumDescriptor<::proto::response::ResponsePOJO_Type>()
        {
            return ::proto::response::ResponsePOJO_Type_descriptor();
        }

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>

#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Response_2eproto
